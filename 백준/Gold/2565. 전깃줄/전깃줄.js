const input = require("fs")
  .readFileSync(process.platform === "linux" ? "/dev/stdin" : "input.txt")
  .toString()
  .trim()
  .split("\n");

/**
 * DP 문제는 왜!!!!! 실버 문제랑 골드 문제랑 이렇게 난이도 차이가 심할까요!!!!!
 *
 * 이 문제도 LIS 문제인 거 같은데..
 *
 * 우선 시작점과 끝점에 대한 배열을 주니 시작점에 대한 오름차순으로 배열을 정렬하고 생각해봅시다.
 */

const [n, ...A] = input;

const arr = A.map((el) => el.trim().split(" ").map(Number));

/**
 * 아래와 같이 정렬된 배열은 종료점을 이렇게 가질겁니다.
 * [8, 2, 9, 1, 4, 6, 7, 10]
 * 그럼 1번 인덱스부터 확인해봅시다.
 *
 * i = 1 => [2, 2]에 해당하는 줄은 [1, 8]에 해당하는 줄과 교차합니다.
 * i = 2 => [3, 9]에 해당하는 줄은 [1, 8]에 해당하는 줄과는 교차하지 않고, [2, 2]에 해당하는 줄과 교차합니다.
 * i = 3 => [4, 1]에 해당하는 줄은 [1, 8], [2, 2], [3, 9]에 해당하는 줄과 모두 교차합니다.
 * 아하!!!! 현재 인덱스의 종료점이 이전 인덱스의 종료점보다 작다면 이는 교차하는 줄입니다.
 *
 * 그럼 현재 인덱스의 종료점이 이전 인덱스의 종료점들보다 크다면 이는 교차하지 않는 줄이라는 거겠죠??
 *
 * 그럼 이렇게 나온 값을 n에 빼면 그게 없애야 하는 전깃줄의 최소 개수입니다.
 */

arr.sort((a, b) => a[0] - b[0]);

const dp = Array(Number(n)).fill(1);

for (let i = 1; i < n; i++) {
  for (let j = 0; j < i; j++) {
    if (arr[i][1] > arr[j][1]) dp[i] = Math.max(dp[i], dp[j] + 1);
  }
}

console.log(n - Math.max(...dp));
