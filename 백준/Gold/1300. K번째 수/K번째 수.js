const input = require("fs")
  .readFileSync(process.platform === "linux" ? "/dev/stdin" : "input.txt")
  .toString()
  .trim()
  .split("\n");

/**
 * 조금 생각을 해봤는데.. 우선 배열 A를 직접 만들 수는 없습니다. N의 최대값은 10 ** 5니까요..
 *
 * 그럼 우리는 직접 A 배열을 만들지 않고 k번 째 수를 찾아야만 합니다.. 아니 어떻게 풀지?..
 *
 * 일단 입력 예제 1의 경우엔 오름차순으로 정렬한 배열이 다음과 같이 나옵니다.
 * [1, 2, 2, 3, 3, 4, 6, 6, 9];
 *
 * 자 여기서 k는 7로 값은 6이 나오는데요..
 * k번째 수가 x일 때, x보다 같거나 작은 수의 개수가 k개라는 뜻이기도 하죠..? 6보다 작거나 같은 수가 7개니까요.
 *
 * 그리고 N이 3일 때 각 행은 아래와 같이 구성됩니다.
 * 1 2 3
 * 2 4 6
 * 3 6 9
 * 알아서 오름차순이 되어있기도 하네요.. 그리고 각 행은 N, 2N, 3N 까지 구성되네요..
 *
 * 자 그럼 x가 6일 때, 각 행의 x 이하의 개수는 몇 개일까요?
 *
 * 1 2 3 => 모두 6이하네요.
 * 2 4 6 => 모두 6이하네요.
 * 3 6 => 9를 제외한 2개의 수가 6이하네요.
 *
 * 그럼 각 행은 N, 2N, 3N... 이렇게 증가할테니 N / i의 개수만큼 나오겠죠?
 * 예를 들어 1행이 1, 2, 3, 4, 5, 6 이렇게 6개로 구성되었다면 6개였을테니까요.
 *
 * 그리고 N을 초과할 수 없으니
 * min(x / i, n)으로 구할 수 있겠네요..
 */

const [n, k] = input.map(Number);

let st = 1; // A[i][j] = i * j 인데, 인덱스는 1부터 시작하니, 1 * 1 = 1이 st.
let en = n * n; // 위의 이유로 가장 마지막 인덱스는 예를 들어, n일 때, A[3][3] = 9니까.. n * n이 나올 수 있는 최대.

let ans = 0;

while (st <= en) {
  const mid = Math.floor((st + en) / 2);

  let cnt = 0;

  for (let i = 1; i <= n; i++) {
    cnt += Math.min(Math.floor(mid / i), n);
  }

  if (cnt >= k) {
    // x보다 작거나 같은 수의 개수가 k개 이상이면 x는 k번째 수의 후보가 될 수 있습니다..
    ans = mid;
    en = mid - 1;
  } else {
    st = mid + 1;
  }
}

console.log(ans);